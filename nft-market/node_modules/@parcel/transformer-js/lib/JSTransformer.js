"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _sourceMap() {
  const data = _interopRequireDefault(require("@parcel/source-map"));

  _sourceMap = function () {
    return data;
  };

  return data;
}

function _plugin() {
  const data = require("@parcel/plugin");

  _plugin = function () {
    return data;
  };

  return data;
}

function _native() {
  const data = require("../native");

  _native = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _browserslist() {
  const data = _interopRequireDefault(require("browserslist"));

  _browserslist = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _diagnostic() {
  const data = _interopRequireWildcard(require("@parcel/diagnostic"));

  _diagnostic = function () {
    return data;
  };

  return data;
}

function _micromatch() {
  const data = require("micromatch");

  _micromatch = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const JSX_EXTENSIONS = {
  '.jsx': true,
  '.tsx': true
};
const JSX_PRAGMA = {
  react: {
    pragma: 'React.createElement',
    pragmaFrag: 'React.Fragment'
  },
  preact: {
    pragma: 'h',
    pragmaFrag: 'Fragment'
  },
  nervjs: {
    pragma: 'Nerv.createElement',
    pragmaFrag: undefined
  },
  hyperapp: {
    pragma: 'h',
    pragmaFrag: undefined
  }
};
const BROWSER_MAPPING = {
  and_chr: 'chrome',
  and_ff: 'firefox',
  ie_mob: 'ie',
  ios_saf: 'ios',
  op_mob: 'opera',
  and_qq: null,
  and_uc: null,
  baidu: null,
  bb: null,
  kaios: null,
  op_mini: null
};
const CONFIG_SCHEMA = {
  type: 'object',
  properties: {
    inlineFS: {
      type: 'boolean'
    },
    inlineEnvironment: {
      oneOf: [{
        type: 'boolean'
      }, {
        type: 'array',
        items: {
          type: 'string'
        }
      }]
    }
  },
  additionalProperties: false
};

var _default = new (_plugin().Transformer)({
  async loadConfig({
    config,
    options
  }) {
    var _pkg$dependencies2, _pkg$devDependencies2, _pkg$peerDependencies2;

    let pkg = await config.getPackage();
    let reactLib;

    if (config.isSource) {
      if (pkg !== null && pkg !== void 0 && pkg.alias && pkg.alias['react']) {
        // e.g.: `{ alias: { "react": "preact/compat" } }`
        reactLib = 'react';
      } else {
        // Find a dependency that we can map to a JSX pragma
        reactLib = Object.keys(JSX_PRAGMA).find(libName => {
          var _pkg$dependencies, _pkg$devDependencies, _pkg$peerDependencies;

          return (pkg === null || pkg === void 0 ? void 0 : (_pkg$dependencies = pkg.dependencies) === null || _pkg$dependencies === void 0 ? void 0 : _pkg$dependencies[libName]) || (pkg === null || pkg === void 0 ? void 0 : (_pkg$devDependencies = pkg.devDependencies) === null || _pkg$devDependencies === void 0 ? void 0 : _pkg$devDependencies[libName]) || (pkg === null || pkg === void 0 ? void 0 : (_pkg$peerDependencies = pkg.peerDependencies) === null || _pkg$peerDependencies === void 0 ? void 0 : _pkg$peerDependencies[libName]);
        });
      }
    }

    let reactRefresh = config.isSource && options.hmrOptions && options.mode === 'development' && Boolean((pkg === null || pkg === void 0 ? void 0 : (_pkg$dependencies2 = pkg.dependencies) === null || _pkg$dependencies2 === void 0 ? void 0 : _pkg$dependencies2.react) || (pkg === null || pkg === void 0 ? void 0 : (_pkg$devDependencies2 = pkg.devDependencies) === null || _pkg$devDependencies2 === void 0 ? void 0 : _pkg$devDependencies2.react) || (pkg === null || pkg === void 0 ? void 0 : (_pkg$peerDependencies2 = pkg.peerDependencies) === null || _pkg$peerDependencies2 === void 0 ? void 0 : _pkg$peerDependencies2.react)); // Check if we should ignore fs calls
    // See https://github.com/defunctzombie/node-browser-resolve#skip

    let ignoreFS = pkg && pkg.browser && typeof pkg.browser === 'object' && pkg.browser.fs === false;
    let result = await config.getConfigFrom(_path().default.join(options.projectRoot, 'index'), ['package.json']);
    let rootPkg = result === null || result === void 0 ? void 0 : result.contents;
    let inlineEnvironment = config.isSource;
    let inlineFS = !ignoreFS;

    if (result && rootPkg !== null && rootPkg !== void 0 && rootPkg['@parcel/transformer-js']) {
      var _rootPkg$ParcelTran, _rootPkg$ParcelTran2;

      _utils().validateSchema.diagnostic(CONFIG_SCHEMA, {
        data: rootPkg['@parcel/transformer-js'],
        // FIXME
        source: await options.inputFS.readFile(result.filePath, 'utf8'),
        filePath: result.filePath,
        prependKey: `/${(0, _diagnostic().encodeJSONKeyComponent)('@parcel/transformer-js')}`
      }, // FIXME
      '@parcel/transformer-js', 'Invalid config for @parcel/transformer-js');

      inlineEnvironment = (_rootPkg$ParcelTran = rootPkg['@parcel/transformer-js'].inlineEnvironment) !== null && _rootPkg$ParcelTran !== void 0 ? _rootPkg$ParcelTran : inlineEnvironment;
      inlineFS = (_rootPkg$ParcelTran2 = rootPkg['@parcel/transformer-js'].inlineFS) !== null && _rootPkg$ParcelTran2 !== void 0 ? _rootPkg$ParcelTran2 : inlineFS;
    }

    let pragma = reactLib ? JSX_PRAGMA[reactLib].pragma : undefined;
    let pragmaFrag = reactLib ? JSX_PRAGMA[reactLib].pragmaFrag : undefined;

    let isJSX = pragma || JSX_EXTENSIONS[_path().default.extname(config.searchPath)];

    config.setResult({
      isJSX,
      pragma,
      pragmaFrag,
      inlineEnvironment,
      inlineFS,
      reactRefresh
    });
  },

  async transform({
    asset,
    config,
    options
  }) {
    // When this asset is an bundle entry, allow that bundle to be split to load shared assets separately.
    // Only set here if it is null to allow previous transformers to override this behavior.
    if (asset.isSplittable == null) {
      asset.isSplittable = true;
    }

    let [code, originalMap] = await Promise.all([asset.getBuffer(), asset.getMap(), _native().init]);
    let targets;

    if (asset.isSource) {
      if (asset.env.isElectron() && asset.env.engines.electron) {
        var _semver$minVersion;

        targets = {
          electron: (_semver$minVersion = _semver().default.minVersion(asset.env.engines.electron)) === null || _semver$minVersion === void 0 ? void 0 : _semver$minVersion.toString()
        };
      } else if (asset.env.isBrowser() && asset.env.engines.browsers) {
        targets = {};
        let browsers = (0, _browserslist().default)(asset.env.engines.browsers);

        for (let browser of browsers) {
          let [name, version] = browser.split(' ');

          if (BROWSER_MAPPING.hasOwnProperty(name)) {
            name = BROWSER_MAPPING[name];

            if (!name) {
              continue;
            }
          }

          let [major, minor = '0', patch = '0'] = version.split('-')[0].split('.');
          let semverVersion = `${major}.${minor}.${patch}`;

          if (targets[name] == null || _semver().default.gt(targets[name], semverVersion)) {
            targets[name] = semverVersion;
          }
        }
      } else if (asset.env.isNode() && asset.env.engines.node) {
        var _semver$minVersion2;

        targets = {
          node: (_semver$minVersion2 = _semver().default.minVersion(asset.env.engines.node)) === null || _semver$minVersion2 === void 0 ? void 0 : _semver$minVersion2.toString()
        };
      }
    }

    let relativePath = _path().default.relative(options.projectRoot, asset.filePath);

    let env = {};

    if (!(config !== null && config !== void 0 && config.inlineEnvironment)) {
      if (options.env.NODE_ENV != null) {
        env.NODE_ENV = options.env.NODE_ENV;
      }
    } else if (Array.isArray(config === null || config === void 0 ? void 0 : config.inlineEnvironment)) {
      for (let key in options.env) {
        if ((0, _micromatch().isMatch)(key, config.inlineEnvironment)) {
          env[key] = String(options.env[key]);
        }
      }
    } else {
      for (let key in options.env) {
        if (!key.startsWith('npm_')) {
          env[key] = String(options.env[key]);
        }
      }
    }

    let {
      dependencies,
      code: compiledCode,
      map,
      shebang,
      hoist_result,
      needs_esm_helpers,
      diagnostics,
      used_env
    } = (0, _native().transform)({
      filename: asset.filePath,
      code,
      module_id: asset.id,
      project_root: options.projectRoot,
      replace_env: !asset.env.isNode(),
      inline_fs: Boolean(config === null || config === void 0 ? void 0 : config.inlineFS) && !asset.env.isNode(),
      insert_node_globals: !asset.env.isNode(),
      is_browser: asset.env.isBrowser(),
      env,
      is_type_script: asset.type === 'ts' || asset.type === 'tsx',
      is_jsx: Boolean(config === null || config === void 0 ? void 0 : config.isJSX),
      jsx_pragma: config === null || config === void 0 ? void 0 : config.pragma,
      jsx_pragma_frag: config === null || config === void 0 ? void 0 : config.pragmaFrag,
      is_development: options.mode === 'development',
      react_refresh: asset.env.isBrowser() && !asset.env.isWorker() && Boolean(config === null || config === void 0 ? void 0 : config.reactRefresh),
      targets,
      source_maps: !!asset.env.sourceMap,
      scope_hoist: asset.env.shouldScopeHoist
    });

    let convertLoc = loc => {
      let location = {
        filePath: relativePath,
        start: {
          line: loc.start_line,
          column: loc.start_col
        },
        end: {
          line: loc.end_line,
          column: loc.end_col
        }
      }; // If there is an original source map, use it to remap to the original source location.

      if (originalMap) {
        location = (0, _utils().remapSourceLocation)(location, originalMap);
      }

      return location;
    };

    if (diagnostics) {
      throw new (_diagnostic().default)({
        diagnostic: diagnostics.map(diagnostic => {
          var _diagnostic$code_high;

          return {
            filePath: asset.filePath,
            message: diagnostic.message,
            codeFrame: {
              code: code.toString(),
              codeHighlights: (_diagnostic$code_high = diagnostic.code_highlights) === null || _diagnostic$code_high === void 0 ? void 0 : _diagnostic$code_high.map(highlight => {
                let {
                  start,
                  end
                } = convertLoc(highlight.loc);
                return {
                  message: highlight.message,
                  start,
                  end
                };
              })
            },
            hints: diagnostic.hints
          };
        })
      });
    }

    if (shebang) {
      asset.meta.interpreter = shebang;
    }

    for (let env of used_env) {
      asset.invalidateOnEnvChange(env);
    }

    for (let dep of dependencies) {
      if (dep.kind === 'WebWorker') {
        asset.addURLDependency(dep.specifier, {
          loc: convertLoc(dep.loc),
          env: {
            context: 'web-worker' // outputFormat:
            //   isModule && asset.env.scopeHoist ? 'esmodule' : undefined,

          },
          meta: {
            webworker: true
          }
        });
      } else if (dep.kind === 'ServiceWorker') {
        asset.addURLDependency(dep.specifier, {
          loc: convertLoc(dep.loc),
          isEntry: true,
          env: {
            context: 'service-worker'
          }
        });
      } else if (dep.kind === 'ImportScripts') {
        if (asset.env.isWorker()) {
          asset.addURLDependency(dep.specifier, {
            loc: convertLoc(dep.loc)
          });
        }
      } else if (dep.kind === 'URL') {
        asset.addURLDependency(dep.specifier, {
          loc: convertLoc(dep.loc)
        });
      } else if (dep.kind === 'File') {
        asset.addIncludedFile(dep.specifier);
      } else {
        if (dep.kind === 'DynamicImport' && (0, _utils().isURL)(dep.specifier)) {
          continue;
        }

        let meta = {
          kind: dep.kind
        };

        if (dep.attributes) {
          meta.importAttributes = dep.attributes;
        }

        asset.addDependency({
          moduleSpecifier: dep.specifier,
          loc: convertLoc(dep.loc),
          isAsync: dep.kind === 'DynamicImport',
          isOptional: dep.is_optional,
          meta,
          resolveFrom: dep.is_helper ? __filename : undefined
        });
      }
    }

    if (hoist_result) {
      asset.symbols.ensure();

      for (let symbol in hoist_result.exported_symbols) {
        let [local, loc] = hoist_result.exported_symbols[symbol];
        asset.symbols.set(symbol, local, convertLoc(loc));
      }

      let deps = new Map(asset.getDependencies().map(dep => [dep.moduleSpecifier, dep]));

      for (let dep of deps.values()) {
        dep.symbols.ensure();
      }

      for (let name in hoist_result.imported_symbols) {
        let [moduleSpecifier, exported, loc] = hoist_result.imported_symbols[name];
        let dep = deps.get(moduleSpecifier);
        if (!dep) continue;
        dep.symbols.set(exported, name, convertLoc(loc));
      }

      for (let [name, moduleSpecifier, exported, loc] of hoist_result.re_exports) {
        let dep = deps.get(moduleSpecifier);
        if (!dep) continue;

        if (name === '*' && exported === '*') {
          dep.symbols.set('*', '*', convertLoc(loc), true);
        } else {
          var _dep$symbols$get$loca, _dep$symbols$get;

          let reExportName = (_dep$symbols$get$loca = (_dep$symbols$get = dep.symbols.get(exported)) === null || _dep$symbols$get === void 0 ? void 0 : _dep$symbols$get.local) !== null && _dep$symbols$get$loca !== void 0 ? _dep$symbols$get$loca : `$${asset.id}$re_export$${name}`;
          asset.symbols.set(name, reExportName);
          dep.symbols.set(exported, reExportName, convertLoc(loc), true);
        }
      }

      for (let moduleSpecifier of hoist_result.wrapped_requires) {
        let dep = deps.get(moduleSpecifier);
        if (!dep) continue;
        dep.meta.shouldWrap = true;
      }

      for (let name in hoist_result.dynamic_imports) {
        let dep = deps.get(hoist_result.dynamic_imports[name]);
        if (!dep) continue;
        dep.meta.promiseSymbol = name;
      }

      if (hoist_result.self_references.length > 0) {
        let symbols = new Map();

        for (let name of hoist_result.self_references) {
          // Do not create a self-reference for the `default` symbol unless we have seen an __esModule flag.
          if (name === 'default' && !asset.symbols.hasExportSymbol('__esModule')) {
            continue;
          }

          let local = (0, _nullthrows().default)(asset.symbols.get(name)).local;
          symbols.set(name, {
            local,
            isWeak: false,
            loc: null
          });
        }

        asset.addDependency({
          moduleSpecifier: `./${_path().default.basename(asset.filePath)}`,
          symbols
        });
      } // Add * symbol if there are CJS exports, no imports/exports at all, or the asset is wrapped.
      // This allows accessing symbols that don't exist without errors in symbol propagation.


      if (hoist_result.has_cjs_exports || !hoist_result.is_esm && deps.size === 0 && Object.keys(hoist_result.exported_symbols).length === 0 || hoist_result.should_wrap && !asset.symbols.hasExportSymbol('*')) {
        asset.symbols.set('*', `$${asset.id}$exports`);
      }

      asset.meta.hasCJSExports = hoist_result.has_cjs_exports;
      asset.meta.staticExports = hoist_result.static_cjs_exports;
      asset.meta.shouldWrap = hoist_result.should_wrap;
      asset.meta.id = asset.id;
    } else if (needs_esm_helpers) {
      asset.addDependency({
        moduleSpecifier: '@parcel/transformer-js/src/esmodule-helpers.js',
        resolveFrom: __filename,
        env: {
          includeNodeModules: {
            '@parcel/transformer-js': true
          }
        }
      });
    }

    asset.type = 'js';
    asset.setBuffer(compiledCode);

    if (map) {
      let sourceMap = new (_sourceMap().default)(options.projectRoot);
      sourceMap.addVLQMap(JSON.parse(map));

      if (originalMap) {
        sourceMap.extends(originalMap);
      }

      asset.setMap(sourceMap);
    }

    return [asset];
  }

});

exports.default = _default;