"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@parcel/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _diagnostic() {
  const data = _interopRequireWildcard(require("@parcel/diagnostic"));

  _diagnostic = function () {
    return data;
  };

  return data;
}

function _stream() {
  const data = require("stream");

  _stream = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _url() {
  const data = _interopRequireDefault(require("url"));

  _url = function () {
    return data;
  };

  return data;
}

function _hash() {
  const data = require("@parcel/hash");

  _hash = function () {
    return data;
  };

  return data;
}

function _Bundle() {
  const data = require("./public/Bundle");

  _Bundle = function () {
    return data;
  };

  return data;
}

function _BundleGraph() {
  const data = _interopRequireWildcard(require("./public/BundleGraph"));

  _BundleGraph = function () {
    return data;
  };

  return data;
}

function _PluginOptions() {
  const data = _interopRequireDefault(require("./public/PluginOptions"));

  _PluginOptions = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("./constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _serializer() {
  const data = require("./serializer");

  _serializer = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const BOUNDARY_LENGTH = _constants().HASH_REF_PREFIX.length + 32 - 1;

class PackagerRunner {
  constructor({
    config,
    configRef,
    farm,
    options,
    optionsRef,
    report
  }) {
    _defineProperty(this, "config", void 0);

    _defineProperty(this, "configRef", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "optionsRef", void 0);

    _defineProperty(this, "farm", void 0);

    _defineProperty(this, "pluginOptions", void 0);

    _defineProperty(this, "distDir", void 0);

    _defineProperty(this, "distExists", void 0);

    _defineProperty(this, "report", void 0);

    _defineProperty(this, "getBundleInfoFromWorker", void 0);

    this.config = config;
    this.configRef = configRef;
    this.options = options;
    this.optionsRef = optionsRef;
    this.pluginOptions = new (_PluginOptions().default)(this.options);
    this.farm = farm;
    this.report = report;
    this.getBundleInfoFromWorker = farm ? farm.createHandle('runPackage') : () => {
      throw new Error('Cannot call PackagerRunner.writeBundleFromWorker() in a worker');
    };
  }

  async writeBundles(bundleGraph) {
    let farm = (0, _nullthrows().default)(this.farm);
    let {
      ref,
      dispose
    } = await farm.createSharedReference(bundleGraph, (0, _serializer().serialize)(bundleGraph));
    let bundleInfoMap = {};
    let writeEarlyPromises = {};
    let hashRefToNameHash = new Map();
    let bundles = bundleGraph.getBundles().filter(bundle => {
      // Do not package and write placeholder bundles to disk. We just
      // need to update the name so other bundles can reference it.
      if (bundle.isPlaceholder) {
        let hash = bundle.id.slice(-8);
        hashRefToNameHash.set(bundle.hashReference, hash);
        let name = (0, _nullthrows().default)(bundle.name).replace(bundle.hashReference, hash);
        bundle.filePath = _path().default.join(bundle.target.distDir, name);
        return false;
      } // skip inline bundles, they will be processed via the parent bundle


      return !bundle.isInline;
    });

    try {
      await Promise.all(bundles.map(async bundle => {
        let info = await this.processBundle(bundle, bundleGraph, ref);
        bundleInfoMap[bundle.id] = info;

        if (!info.hashReferences.length) {
          hashRefToNameHash.set(bundle.hashReference, this.options.shouldContentHash ? info.hash.slice(-8) : bundle.id.slice(-8));
          writeEarlyPromises[bundle.id] = this.writeToDist({
            bundle,
            info,
            hashRefToNameHash,
            bundleGraph
          });
        }
      }));
      assignComplexNameHashes(hashRefToNameHash, bundles, bundleInfoMap, this.options);
      await Promise.all(bundles.map(bundle => {
        var _writeEarlyPromises$b;

        return (_writeEarlyPromises$b = writeEarlyPromises[bundle.id]) !== null && _writeEarlyPromises$b !== void 0 ? _writeEarlyPromises$b : this.writeToDist({
          bundle,
          info: bundleInfoMap[bundle.id],
          hashRefToNameHash,
          bundleGraph
        });
      }));
    } finally {
      await dispose();
    }
  }

  async processBundle(bundle, bundleGraph, bundleGraphReference) {
    let start = Date.now();
    return { ...(await this.getBundleInfoFromWorker({
        bundle,
        bundleGraphReference,
        optionsRef: (0, _nullthrows().default)(this.optionsRef),
        configRef: (0, _nullthrows().default)(this.configRef)
      })),
      time: Date.now() - start
    };
  }

  async loadConfigs(bundleGraph, bundle) {
    let configs = new Map();
    configs.set(bundle.id, await this.loadConfig(bundleGraph, bundle));

    for (let inlineBundle of bundleGraph.getInlineBundles(bundle)) {
      configs.set(inlineBundle.id, await this.loadConfig(bundleGraph, inlineBundle));
    }

    return configs;
  }

  async loadConfig(bundleGraph, bundle) {
    let config;
    let {
      plugin
    } = await this.config.getPackager((0, _nullthrows().default)(bundle.name));

    if (plugin.loadConfig != null) {
      try {
        config = await (0, _nullthrows().default)(plugin.loadConfig)({
          bundle: _Bundle().NamedBundle.get(bundle, bundleGraph, this.options),
          options: this.pluginOptions,
          logger: new (_logger().PluginLogger)({
            origin: this.config.getBundlerName()
          })
        });
      } catch (e) {
        throw new (_diagnostic().default)({
          diagnostic: (0, _diagnostic().errorToDiagnostic)(e, {
            origin: this.config.getBundlerName(),
            filePath: bundle.filePath
          })
        });
      }
    }

    return config;
  }

  getBundleInfoFromCache(infoKey) {
    if (this.options.shouldDisableCache) {
      return;
    }

    return this.options.cache.get(infoKey);
  }

  async getBundleInfo(bundle, bundleGraph, cacheKeys, configs) {
    let {
      type,
      contents,
      map
    } = await this.getBundleResult(bundle, bundleGraph, configs);
    return this.writeToCache(cacheKeys, type, contents, map);
  }

  async getBundleResult(bundle, bundleGraph, configs) {
    var _packaged$type, _res$type;

    let packaged = await this.package(bundle, bundleGraph, configs);
    let type = (_packaged$type = packaged.type) !== null && _packaged$type !== void 0 ? _packaged$type : bundle.type;
    let res = await this.optimize(bundle, bundleGraph, type, packaged.contents, packaged.map);
    let map = res.map != null ? await this.generateSourceMap(bundle, res.map) : null;
    return {
      type: (_res$type = res.type) !== null && _res$type !== void 0 ? _res$type : type,
      contents: res.contents,
      map
    };
  }

  getSourceMapReference(bundle, map) {
    if (map && bundle.env.sourceMap && !bundle.isInline) {
      if (bundle.env.sourceMap && bundle.env.sourceMap.inline) {
        return this.generateSourceMap((0, _Bundle().bundleToInternalBundle)(bundle), map);
      } else {
        return _path().default.basename(bundle.name) + '.map';
      }
    } else {
      return null;
    }
  }

  async package(internalBundle, bundleGraph, configs) {
    let bundle = _Bundle().NamedBundle.get(internalBundle, bundleGraph, this.options);

    this.report({
      type: 'buildProgress',
      phase: 'packaging',
      bundle
    });
    let {
      name,
      plugin
    } = await this.config.getPackager(bundle.name);

    try {
      var _configs$get;

      return await plugin.package({
        config: (_configs$get = configs.get(bundle.id)) === null || _configs$get === void 0 ? void 0 : _configs$get.config,
        bundle,
        bundleGraph: new (_BundleGraph().default)(bundleGraph, _Bundle().NamedBundle.get, this.options),
        getSourceMapReference: map => {
          return this.getSourceMapReference(bundle, map);
        },
        options: this.pluginOptions,
        logger: new (_logger().PluginLogger)({
          origin: name
        }),
        getInlineBundleContents: async (bundle, bundleGraph) => {
          if (!bundle.isInline) {
            throw new Error('Bundle is not inline and unable to retrieve contents');
          }

          let res = await this.getBundleResult((0, _Bundle().bundleToInternalBundle)(bundle), // $FlowFixMe
          (0, _BundleGraph().bundleGraphToInternalBundleGraph)(bundleGraph), configs);
          return {
            contents: res.contents
          };
        }
      });
    } catch (e) {
      throw new (_diagnostic().default)({
        diagnostic: (0, _diagnostic().errorToDiagnostic)(e, {
          origin: name,
          filePath: _path().default.join(bundle.target.distDir, bundle.name)
        })
      });
    }
  }

  async optimize(internalBundle, internalBundleGraph, type, contents, map) {
    let bundle = _Bundle().NamedBundle.get(internalBundle, internalBundleGraph, this.options);

    let bundleGraph = new (_BundleGraph().default)(internalBundleGraph, _Bundle().NamedBundle.get, this.options);
    let optimizers = await this.config.getOptimizers(bundle.name, internalBundle.pipeline);

    if (!optimizers.length) {
      return {
        type: bundle.type,
        contents,
        map
      };
    }

    this.report({
      type: 'buildProgress',
      phase: 'optimizing',
      bundle
    });
    let optimized = {
      type,
      contents,
      map
    };

    for (let optimizer of optimizers) {
      try {
        var _next$type;

        let next = await optimizer.plugin.optimize({
          bundle,
          bundleGraph,
          contents: optimized.contents,
          map: optimized.map,
          getSourceMapReference: map => {
            return this.getSourceMapReference(bundle, map);
          },
          options: this.pluginOptions,
          logger: new (_logger().PluginLogger)({
            origin: optimizer.name
          })
        });
        optimized.type = (_next$type = next.type) !== null && _next$type !== void 0 ? _next$type : optimized.type;
        optimized.contents = next.contents;
        optimized.map = next.map;
      } catch (e) {
        throw new (_diagnostic().default)({
          diagnostic: (0, _diagnostic().errorToDiagnostic)(e, {
            origin: optimizer.name,
            filePath: _path().default.join(bundle.target.distDir, bundle.name)
          })
        });
      }
    }

    return optimized;
  }

  async generateSourceMap(bundle, map) {
    // sourceRoot should be a relative path between outDir and rootDir for node.js targets
    let filePath = _path().default.join(bundle.target.distDir, (0, _nullthrows().default)(bundle.name));

    let sourceRoot = _path().default.relative(_path().default.dirname(filePath), this.options.projectRoot);

    let inlineSources = false;

    if (bundle.target) {
      if (bundle.env.sourceMap && bundle.env.sourceMap.sourceRoot !== undefined) {
        sourceRoot = bundle.env.sourceMap.sourceRoot;
      } else if (this.options.serveOptions && bundle.target.env.context === 'browser') {
        sourceRoot = '/__parcel_source_root';
      }

      if (bundle.env.sourceMap && bundle.env.sourceMap.inlineSources !== undefined) {
        inlineSources = bundle.env.sourceMap.inlineSources;
      } else if (bundle.target.env.context !== 'node') {
        // inlining should only happen in production for browser targets by default
        inlineSources = this.options.mode === 'production';
      }
    }

    let isInlineMap = bundle.env.sourceMap && bundle.env.sourceMap.inline;
    let stringified = await map.stringify({
      file: _path().default.basename(filePath + '.map'),
      // $FlowFixMe
      fs: this.options.inputFS,
      rootDir: this.options.projectRoot,
      sourceRoot: !inlineSources ? _url().default.format(_url().default.parse(sourceRoot + '/')) : undefined,
      inlineSources,
      format: isInlineMap ? 'inline' : 'string'
    });
    (0, _assert().default)(typeof stringified === 'string');
    return stringified;
  }

  async getCacheKey(bundle, bundleGraph, configs) {
    let name = (0, _nullthrows().default)(bundle.name); // TODO: include packagers and optimizers used in inline bundles as well

    let {
      version: packager
    } = await this.config.getPackager(name);
    let optimizers = (await this.config.getOptimizers(name)).map(({
      name,
      version
    }) => name + version).join('');
    let configResults = {};

    for (let [id, config] of configs) {
      configResults[id] = config === null || config === void 0 ? void 0 : config.config;
    } // TODO: add third party configs to the cache key


    let {
      publicUrl
    } = bundle.target;
    return (0, _hash().hashString)(_constants().PARCEL_VERSION + packager + optimizers + publicUrl + bundleGraph.getHash(bundle) + JSON.stringify(configResults));
  }

  async readFromCache(cacheKey) {
    let contentKey = PackagerRunner.getContentKey(cacheKey);
    let mapKey = PackagerRunner.getMapKey(cacheKey);
    let contentExists = await this.options.cache.has(contentKey);

    if (!contentExists) {
      return null;
    }

    let mapExists = await this.options.cache.has(mapKey);
    return {
      contents: this.options.cache.getStream(contentKey),
      map: mapExists ? this.options.cache.getStream(mapKey) : null
    };
  }

  async writeToDist({
    bundle,
    bundleGraph,
    info,
    hashRefToNameHash
  }) {
    var _info$time;

    let {
      inputFS,
      outputFS
    } = this.options;
    let name = (0, _nullthrows().default)(bundle.name);
    let thisHashReference = bundle.hashReference;

    if (info.type !== bundle.type) {
      name = name.slice(0, -_path().default.extname(name).length) + '.' + info.type;
      bundle.type = info.type;
    }

    if (name.includes(thisHashReference)) {
      let thisNameHash = (0, _nullthrows().default)(hashRefToNameHash.get(thisHashReference));
      name = name.replace(thisHashReference, thisNameHash);
    }

    let filePath = _path().default.join(bundle.target.distDir, name);

    bundle.filePath = filePath;

    let dir = _path().default.dirname(filePath);

    await outputFS.mkdirp(dir); // ? Got rid of dist exists, is this an expensive operation
    // Use the file mode from the entry asset as the file mode for the bundle.
    // Don't do this for browser builds, as the executable bit in particular is unnecessary.

    let publicBundle = _Bundle().NamedBundle.get(bundle, bundleGraph, this.options);

    let mainEntry = publicBundle.getMainEntry();
    let writeOptions = publicBundle.env.isBrowser() || !mainEntry ? undefined : {
      mode: (await inputFS.stat(mainEntry.filePath)).mode
    };
    let cacheKeys = info.cacheKeys;
    let contentStream = this.options.cache.getStream(cacheKeys.content);
    let size = await writeFileStream(outputFS, filePath, contentStream, info.hashReferences, hashRefToNameHash, writeOptions);
    bundle.stats = {
      size,
      time: (_info$time = info.time) !== null && _info$time !== void 0 ? _info$time : 0
    };
    let mapKey = cacheKeys.map;

    if (bundle.env.sourceMap && !bundle.env.sourceMap.inline && (await this.options.cache.has(mapKey))) {
      let mapStream = this.options.cache.getStream(mapKey);
      await writeFileStream(outputFS, filePath + '.map', mapStream, info.hashReferences, hashRefToNameHash);
    }
  }

  async writeToCache(cacheKeys, type, contents, map) {
    let size = 0;
    let hash;
    let hashReferences = []; // TODO: don't replace hash references in binary files??

    if (contents instanceof _stream().Readable) {
      let boundaryStr = '';
      let h = new (_hash().Hash)();
      await this.options.cache.setStream(cacheKeys.content, (0, _utils().blobToStream)(contents).pipe(new (_utils().TapStream)(buf => {
        var _str$match;

        let str = boundaryStr + buf.toString();
        hashReferences = hashReferences.concat((_str$match = str.match(_constants().HASH_REF_REGEX)) !== null && _str$match !== void 0 ? _str$match : []);
        size += buf.length;
        h.writeBuffer(buf);
        boundaryStr = str.slice(str.length - BOUNDARY_LENGTH);
      })));
      hash = h.finish();
    } else if (typeof contents === 'string') {
      var _contents$match;

      size = Buffer.byteLength(contents);
      hash = (0, _hash().hashString)(contents);
      hashReferences = (_contents$match = contents.match(_constants().HASH_REF_REGEX)) !== null && _contents$match !== void 0 ? _contents$match : [];
      await this.options.cache.setBlob(cacheKeys.content, contents);
    } else {
      var _contents$toString$ma;

      size = contents.length;
      hash = (0, _hash().hashBuffer)(contents);
      hashReferences = (_contents$toString$ma = contents.toString().match(_constants().HASH_REF_REGEX)) !== null && _contents$toString$ma !== void 0 ? _contents$toString$ma : [];
      await this.options.cache.setBlob(cacheKeys.content, contents);
    }

    if (map != null) {
      await this.options.cache.setBlob(cacheKeys.map, map);
    }

    let info = {
      type,
      size,
      hash,
      hashReferences,
      cacheKeys
    };
    await this.options.cache.set(cacheKeys.info, info);
    return info;
  }

  static getContentKey(cacheKey) {
    return (0, _hash().hashString)(`${cacheKey}:content`);
  }

  static getMapKey(cacheKey) {
    return (0, _hash().hashString)(`${cacheKey}:map`);
  }

  static getInfoKey(cacheKey) {
    return (0, _hash().hashString)(`${cacheKey}:info`);
  }

}

exports.default = PackagerRunner;

function writeFileStream(fs, filePath, stream, hashReferences, hashRefToNameHash, options) {
  return new Promise((resolve, reject) => {
    let initialStream = hashReferences.length ? stream.pipe(replaceStream(hashRefToNameHash)) : stream;
    let fsStream = fs.createWriteStream(filePath, options);
    let fsStreamClosed = new Promise(resolve => {
      fsStream.on('close', () => resolve());
    });
    let bytesWritten = 0;
    initialStream.pipe(new (_utils().TapStream)(buf => {
      bytesWritten += buf.length;
    })).pipe(fsStream).on('finish', () => resolve(fsStreamClosed.then(() => bytesWritten))).on('error', reject);
  });
}

function replaceStream(hashRefToNameHash) {
  let boundaryStr = '';
  return new (_stream().Transform)({
    transform(chunk, encoding, cb) {
      let str = boundaryStr + chunk.toString();
      let replaced = str.replace(_constants().HASH_REF_REGEX, match => {
        return hashRefToNameHash.get(match) || match;
      });
      boundaryStr = replaced.slice(replaced.length - BOUNDARY_LENGTH);
      let strUpToBoundary = replaced.slice(0, replaced.length - BOUNDARY_LENGTH);
      cb(null, strUpToBoundary);
    },

    flush(cb) {
      cb(null, boundaryStr);
    }

  });
}

function assignComplexNameHashes(hashRefToNameHash, bundles, bundleInfoMap, options) {
  for (let bundle of bundles) {
    if (hashRefToNameHash.get(bundle.hashReference) != null) {
      continue;
    }

    hashRefToNameHash.set(bundle.hashReference, options.shouldContentHash ? (0, _hash().hashString)([...getBundlesIncludedInHash(bundle.id, bundleInfoMap)].map(bundleId => bundleInfoMap[bundleId].hash).join(':')).slice(-8) : bundle.id.slice(-8));
  }
}

function getBundlesIncludedInHash(bundleId, bundleInfoMap, included = new Set()) {
  included.add(bundleId);

  for (let hashRef of bundleInfoMap[bundleId].hashReferences) {
    let referencedId = getIdFromHashRef(hashRef);

    if (!included.has(referencedId)) {
      getBundlesIncludedInHash(referencedId, bundleInfoMap, included);
    }
  }

  return included;
}

function getIdFromHashRef(hashRef) {
  return hashRef.slice(_constants().HASH_REF_PREFIX.length);
}