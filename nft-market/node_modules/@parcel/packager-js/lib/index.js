"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _plugin() {
  const data = require("@parcel/plugin");

  _plugin = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _hash() {
  const data = require("@parcel/hash");

  _hash = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _DevPackager() {
  const data = require("./DevPackager");

  _DevPackager = function () {
    return data;
  };

  return data;
}

function _ScopeHoistingPackager() {
  const data = require("./ScopeHoistingPackager");

  _ScopeHoistingPackager = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = new (_plugin().Packager)({
  async loadConfig({
    options
  }) {
    var _pkg$config$name, _pkg$files;

    // Generate a name for the global parcelRequire function that is unique to this project.
    // This allows multiple parcel builds to coexist on the same page.
    let pkg = await (0, _utils().loadConfig)(options.inputFS, _path().default.join(options.entryRoot, 'index'), ['package.json'], options.projectRoot);
    let name = (_pkg$config$name = pkg === null || pkg === void 0 ? void 0 : pkg.config.name) !== null && _pkg$config$name !== void 0 ? _pkg$config$name : '';
    return {
      config: {
        parcelRequireName: 'parcelRequire' + (0, _hash().hashString)(name).slice(-4)
      },
      files: (_pkg$files = pkg === null || pkg === void 0 ? void 0 : pkg.files) !== null && _pkg$files !== void 0 ? _pkg$files : []
    };
  },

  async package({
    bundle,
    bundleGraph,
    getInlineBundleContents,
    getSourceMapReference,
    config,
    options
  }) {
    let packager = bundle.env.shouldScopeHoist ? new (_ScopeHoistingPackager().ScopeHoistingPackager)(options, bundleGraph, bundle, (0, _nullthrows().default)(config).parcelRequireName) : new (_DevPackager().DevPackager)(options, bundleGraph, bundle, (0, _nullthrows().default)(config).parcelRequireName);
    let {
      contents,
      map
    } = await packager.package();
    contents += '\n' + (await getSourceMapSuffix(getSourceMapReference, map));
    return (0, _utils().replaceInlineReferences)({
      bundle,
      bundleGraph,
      contents,
      getInlineReplacement: (dependency, inlineType, content) => ({
        from: `"${dependency.id}"`,
        to: inlineType === 'string' ? JSON.stringify(content) : content
      }),
      getInlineBundleContents,
      map
    });
  }

});

exports.default = _default;

async function getSourceMapSuffix(getSourceMapReference, map) {
  let sourcemapReference = await getSourceMapReference(map);

  if (sourcemapReference != null) {
    return '//# sourceMappingURL=' + sourcemapReference + '\n';
  } else {
    return '';
  }
}