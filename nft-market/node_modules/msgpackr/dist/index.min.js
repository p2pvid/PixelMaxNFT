(function(a,b){"object"==typeof exports&&"undefined"!=typeof module?b(exports):"function"==typeof define&&define.amd?define(["exports"],b):(a=a||self,b(a.msgpackr={}))})(this,function(a){'use strict';var b=Math.floor;function c(){let a=w[C++];if(160>a){if(!(128>a)){if(!(144>a)){a-=144;let b=Array(a);for(let d=0;d<a;d++)b[d]=c();return b}if(a-=128,D.mapsAsObjects){let b={};for(let d=0;d<a;d++)b[m()]=c();return b}else{let b=new Map;for(let d=0;d<a;d++)b.set(c(),c());return b}}else if(64>a)return a;else{let b=y[63&a];if(b)return b.read||(b.read=d(b)),b.read();if(D.getStructures){let c=n(()=>(w=null,D.getStructures()));return!0===y?D.structures=y=c:y.splice.apply(y,[0,c.length].concat(c)),b=y[63&a],b?(b.read||(b.read=d(b)),b.read()):a}return a}}else if(192>a){// fixstr
let b=a-160;if(F>=C)return z.slice(C-E,(C+=b)-E);if(0==F&&140>x){// for small blocks, avoiding the overhead of the extract call is helpful
let a=16>b?j(b):h(b);if(null!=a)return a}return L(b)}else{let b;switch(a){case 192:return null;case 193:return J;// "never-used", return special object to denote that
case 194:return!1;case 195:return!0;case 196:// bin 8
return k(w[C++]);case 197:return b=B.getUint16(C),C+=2,k(b);case 198:return b=B.getUint32(C),C+=4,k(b);case 199:// ext 8
return l(w[C++]);case 200:return b=B.getUint16(C),C+=2,l(b);case 201:return b=B.getUint32(C),C+=4,l(b);case 202:if(b=B.getFloat32(C),2<D.useFloat32){// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
let a=U[(127&w[C])<<1|w[C+1]>>7];return C+=4,(a*b+(0<b?.5:-.5)>>0)/a}return C+=4,b;case 203:return b=B.getFloat64(C),C+=8,b;// uint handlers
case 204:return w[C++];case 205:return b=B.getUint16(C),C+=2,b;case 206:return b=B.getUint32(C),C+=4,b;case 207:return D.uint64AsNumber?72057594037927940*w[C++]+281474976710656*w[C++]+1099511627776*w[C++]+4294967296*w[C++]+16777216*w[C++]+(w[C++]<<16)+(w[C++]<<8)+w[C++]:(b=B.getBigUint64(C),C+=8,b);// int handlers
case 208:return B.getInt8(C++);case 209:return b=B.getInt16(C),C+=2,b;case 210:return b=B.getInt32(C),C+=4,b;case 211:return b=B.getBigInt64(C),C+=8,b;case 212:if(b=w[C++],114==b)return R(w[C++]);else{let a=G[b];if(a)return a.read?(C++,a.read(c())):a(w.subarray(C,++C));throw new Error("Unknown extension "+b)}case 213:// fixext 2
return l(2);case 214:// fixext 4
return l(4);case 215:// fixext 8
return l(8);case 216:// fixext 16
return l(16);case 217:return b=w[C++],F>=C?z.slice(C-E,(C+=b)-E):M(b);case 218:return b=B.getUint16(C),C+=2,F>=C?z.slice(C-E,(C+=b)-E):N(b);case 219:return b=B.getUint32(C),C+=4,F>=C?z.slice(C-E,(C+=b)-E):O(b);case 220:return b=B.getUint16(C),C+=2,f(b);case 221:return b=B.getUint32(C),C+=4,f(b);case 222:return b=B.getUint16(C),C+=2,g(b);case 223:return b=B.getUint32(C),C+=4,g(b);default:// negative int
if(224<=a)return a-256;if(void 0===a){let a=new Error("Unexpected end of MessagePack data");throw a.incomplete=!0,a}throw new Error("Unknown MessagePack token "+a);}}}function d(a){function b(){// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
if(2<b.count++)return this.read=new Function("r","return function(){return {"+a.map(a=>K.test(a)?a+":r()":"["+JSON.stringify(a)+"]:r()").join(",")+"}}")(c),this.read();let d={};for(let b,e=0,f=a.length;e<f;e++)b=a[e],d[b]=c();return d}return b.count=0,b}function e(a){let b;if(16>a&&(b=j(a)))return b;if(64<a&&v)return v.decode(w.subarray(C,C+=a));const c=C+a,d=[];for(b="";C<c;){const a=w[C++];if(0==(128&a))d.push(a);else if(192==(224&a)){// 2 bytes
const b=63&w[C++];d.push((31&a)<<6|b)}else if(224==(240&a)){// 3 bytes
const b=63&w[C++],c=63&w[C++];d.push((31&a)<<12|b<<6|c)}else if(240==(248&a)){// 4 bytes
const b=63&w[C++],c=63&w[C++],e=63&w[C++];let f=(7&a)<<18|b<<12|c<<6|e;65535<f&&(f-=65536,d.push(55296|1023&f>>>10),f=56320|1023&f),d.push(f)}else d.push(a);4096<=d.length&&(b+=P.apply(String,d),d.length=0)}return 0<d.length&&(b+=P.apply(String,d)),b}function f(a){let b=Array(a);for(let d=0;d<a;d++)b[d]=c();return b}function g(a){if(D.mapsAsObjects){let b={};for(let d=0;d<a;d++)b[m()]=c();return b}else{let b=new Map;for(let d=0;d<a;d++)b.set(c(),c());return b}}function h(a){let b=C,c=Array(a);for(let d=0;d<a;d++){const a=w[C++];if(0<(128&a))return void(C=b);c[d]=a}return P.apply(String,c)}function j(p){if(4>p){if(!(2>p)){let d=w[C++],a=w[C++];if(0<(128&d)||0<(128&a))return void(C-=2);if(3>p)return P(d,a);let b=w[C++];return 0<(128&b)?void(C-=3):P(d,a,b)}if(0===p)return"";else{let b=w[C++];return 1<(128&b)?void(C-=1):P(b)}}else{let q=w[C++],a=w[C++],b=w[C++],c=w[C++];if(0<(128&q)||0<(128&a)||0<(128&b)||0<(128&c))return void(C-=4);if(6>p){if(4===p)return P(q,a,b,c);else{let d=w[C++];return 0<(128&d)?void(C-=5):P(q,a,b,c,d)}}else if(8>p){let d=w[C++],e=w[C++];if(0<(128&d)||0<(128&e))return void(C-=6);if(7>p)return P(q,a,b,c,d,e);let f=w[C++];return 0<(128&f)?void(C-=7):P(q,a,b,c,d,e,f)}else{let d=w[C++],e=w[C++],f=w[C++],g=w[C++];if(0<(128&d)||0<(128&e)||0<(128&f)||0<(128&g))return void(C-=8);if(10>p){if(8===p)return P(q,a,b,c,d,e,f,g);else{let h=w[C++];return 0<(128&h)?void(C-=9):P(q,a,b,c,d,e,f,g,h)}}else if(12>p){let h=w[C++],i=w[C++];if(0<(128&h)||0<(128&i))return void(C-=10);if(11>p)return P(q,a,b,c,d,e,f,g,h,i);let j=w[C++];return 0<(128&j)?void(C-=11):P(q,a,b,c,d,e,f,g,h,i,j)}else{let h=w[C++],i=w[C++],j=w[C++],k=w[C++];if(0<(128&h)||0<(128&i)||0<(128&j)||0<(128&k))return void(C-=12);if(!(14>p)){let l=w[C++],m=w[C++];if(0<(128&l)||0<(128&m))return void(C-=14);if(15>p)return P(q,a,b,c,d,e,f,g,h,i,j,k,l,m);let n=w[C++];return 0<(128&n)?void(C-=15):P(q,a,b,c,d,e,f,g,h,i,j,k,l,m,n)}if(12===p)return P(q,a,b,c,d,e,f,g,h,i,j,k);else{let l=w[C++];return 0<(128&l)?void(C-=13):P(q,a,b,c,d,e,f,g,h,i,j,k,l)}}}}}function k(a){return D.copyBuffers?// specifically use the copying slice (not the node one)
Uint8Array.prototype.slice.call(w,C,C+=a):w.subarray(C,C+=a)}function l(a){let b=w[C++];if(G[b])return G[b](w.subarray(C,C+=a));throw new Error("Unknown extension type "+b)}function m(){let a=w[C++];if(160<=a&&192>a){if(a-=160,F>=C)// if it has been extracted, must use it (and faster anyway)
return z.slice(C-E,(C+=a)-E);if(!(0==F&&180>x))return L(a)}else return C--,c();let b,d=4095&(a<<5^(1<a?B.getUint16(C):0<a?w[C]:0)),e=Q[d],f=C,g=C+a-3,k=0;if(e&&e.bytes==a){for(;f<g;){if(b=B.getUint32(f),b!=e[k++]){f=1879048192;break}f+=4}for(g+=3;f<g;)if(b=w[f++],b!=e[k++]){f=1879048192;break}if(f===g)return C=f,e.string;g-=3,f=C}for(e=[],Q[d]=e,e.bytes=a;f<g;)b=B.getUint32(f),e.push(b),f+=4;for(g+=3;f<g;)b=w[f++],e.push(b);// for small blocks, avoiding the overhead of the extract call is helpful
let l=16>a?j(a):h(a);return null==l?e.string=L(a):e.string=l}// the registration of the record definition extension (as "r")
// notepack defines extension 0 to mean undefined, so use that as the default here
// registration of bulk record definition?
// currentExtensions[0x52] = () =>
function n(a){let b=x,c=C,d=E,e=F,f=z,g=A,h=new Uint8Array(w.slice(0,x)),i=y,j=D,k=a();return x=b,C=c,E=d,F=e,z=f,A=g,w=h,y=i,D=j,B=new DataView(w.buffer,w.byteOffset,w.byteLength),k}function o(){w=null,A=null,y=null}function p(a){G[a.type]=a.unpack?a.unpack:a}function q(a,b,c){let d=a.byteLength;if(256>d+1){var{target:e,position:f}=c(4+d);e[f++]=199,e[f++]=d+1}else if(65536>d+1){var{target:e,position:f}=c(5+d);e[f++]=200,e[f++]=d+1>>8,e[f++]=255&d+1}else{var{target:e,position:f,targetView:g}=c(7+d);// plus one for the type byte
e[f++]=201,g.setUint32(f,d+1),f+=4}// "t" for typed array
e[f++]=116,e[f++]=b,e.set(new Uint8Array(a.buffer,a.byteOffset,a.byteLength),f)}function r(a,b){let c=a.byteLength;var d,e;if(256>c){var{target:d,position:e}=b(c+2);d[e++]=196,d[e++]=c}else if(65536>c){var{target:d,position:e}=b(c+3);d[e++]=197,d[e++]=c>>8,d[e++]=255&c}else{var{target:d,position:e,targetView:f}=b(c+5);d[e++]=198,f.setUint32(e,c),e+=4}d.set(a,e)}function s(a,b,c,d){let e=a.length;return 1===e?b[c++]=212:2===e?b[c++]=213:4===e?b[c++]=214:8===e?b[c++]=215:16===e?b[c++]=216:256>e?(b[c++]=199,b[c++]=e):65536>e?(b[c++]=200,b[c++]=e>>8,b[c++]=255&e):(b[c++]=201,b[c++]=e>>24,b[c++]=255&e>>16,b[c++]=255&e>>8,b[c++]=255&e),b[c++]=d,b.set(a,c),c+=e,c}function t(a,b){// insert the ids that need to be referenced for structured clones
let c,d=6*b.length,e=a.length-d;for(b.sort((c,a)=>c.offset>a.offset?1:-1);c=b.pop();){let b=c.offset,f=c.id;a.copyWithin(b+d,b,e),d-=6;let g=b+d;// 'i'
a[g++]=214,a[g++]=105,a[g++]=f>>24,a[g++]=255&f>>16,a[g++]=255&f>>8,a[g++]=255&f,e=b}return a}function u(a){if(a.Class){if(!a.pack&&!a.write)throw new Error("Extension has no pack or write function");aa.unshift(a.Class),_.unshift(a)}p(a)}let v;try{v=new TextDecoder}catch(a){}let w,x,y,z,A,B,C=0,D={},E=0,F=0,G=[],H={useRecords:!1,mapsAsObjects:!0};class I{}const J=new I;J.name="MessagePack 0xC1";class i{constructor(a){a&&(!1===a.useRecords&&a.mapsAsObjects===void 0&&(a.mapsAsObjects=!0),a.getStructures&&!a.structures&&((a.structures=[]).uninitialized=!0)),Object.assign(this,a)}unpack(a,b,d){if(w)// re-entrant execution, save the state and restore it after we do this unpack
return n(()=>(o(),this?this.unpack(a,b,d):i.prototype.unpack.call(H,a,b,d)));if(x=-1<b?b:a.length,C=0,F=0,z=null,w=a,B=a.dataView||(a.dataView=new DataView(a.buffer,a.byteOffset,a.byteLength)),!this)D=H,(!y||0<y.length)&&(y=[]);else if(D=this,this.structures){y=this.structures;try{return c()}finally{(C>=x||!d)&&(y=null,w=null,A&&(A=null))}}else(!y||0<y.length)&&(y=[]);try{return c()}finally{(C>=x||!d)&&(w=null,A&&(A=null))}}unpackMultiple(a,b){try{let d,e=this,f=a.length,g=this?this.unpack(a,f,!0):V.unpack(a,f,!0);if(b){for(b(g);C<f;)if(!1===b(c()))return;}else{for(d=[g];C<f;)d.push(c());return d}}finally{o()}}decode(a,b){return this.unpack(a,b)}}const K=/^[a-zA-Z_$][a-zA-Z\d_$]*$/;let L=e,M=e,N=e,O=e,P=String.fromCharCode,Q=Array(4096);const R=a=>{let b=y[63&a]=c();return b.read=d(b),b.read()};let S="object"==typeof window?window:global;G[0]=()=>{},G[101]=()=>{let a=c();return(S[a[0]]||Error)(a[1])},G[105]=()=>{// id extension (for structured clones)
let a=B.getUint32(C-4);A||(A=new Map);let b,d=w[C];b=144<=d&&160>d||220==d||221==d?[]:{};let e={target:b};// a placeholder object
A.set(a,e);let f=c();// read the next value as the target object to id
return e.used?Object.assign(b,f):(e.target=f,f);// no cycle, can just use the returned read object
},G[112]=()=>{// pointer extension (for structured clones)
let a=B.getUint32(C-4),b=A.get(a);return b.used=!0,b.target},G[115]=()=>new Set(c());const T=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map(a=>a+"Array");G[116]=a=>{let b=a[0],c=T[b];if(!c)throw new Error("Could not find typed array for code "+b);// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
return new S[c](Uint8Array.prototype.slice.call(a,1).buffer)},G[120]=()=>{let a=c();return new RegExp(a[0],a[1])},G[255]=a=>{// 32-bit date extension
if(4==a.length)return new Date(1e3*(16777216*a[0]+(a[1]<<16)+(a[2]<<8)+a[3]));if(8==a.length)return new Date(((a[0]<<22)+(a[1]<<14)+(a[2]<<6)+(a[3]>>2))/1e6+1e3*(4294967296*(3&a[3])+16777216*a[4]+(a[5]<<16)+(a[6]<<8)+a[7]));if(12==a.length)// TODO: Implement support for negative
return new Date(((a[0]<<24)+(a[1]<<16)+(a[2]<<8)+a[3])/1e6+1e3*((128&a[4]?-281474976710656:0)+1099511627776*a[6]+4294967296*a[7]+16777216*a[8]+(a[9]<<16)+(a[10]<<8)+a[11]));throw new Error("Invalid timestamp length")};let U=Array(147);// this is a table matching binary exponents to the multiplier to determine significant digit rounding
for(let c=0;256>c;c++)U[c]=+("1e"+b(45.15-.30103*c));let V=new i({useRecords:!1});const W=V.unpack,X=V.unpackMultiple,Y=V.unpack,Z={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4};let $;try{$=new TextEncoder}catch(a){}let _,aa;const ba="undefined"!=typeof Buffer,ca=ba?Buffer.allocUnsafeSlow:Uint8Array,da=ba?Buffer:Uint8Array,ea=ba?4294967296:2144337920;let fa,ga,ha,ia=0;const ja=Symbol("record-id");class ka extends i{constructor(a){super(a),this.offset=0;let b,c,d,e,f,g=0,h=da.prototype.utf8Write?function(a,b,c){return fa.utf8Write(a,b,c)}:!!($&&$.encodeInto)&&function(a,b){return $.encodeInto(a,fa.subarray(b)).written},i=this,j=32,k=a&&a.sequential;k&&(j=0,this.structures=[]);let m=[],n=0,o=0;if(this.structures&&this.structures.length>j)throw new Error("Too many shared structures");this.pack=this.encode=function(a){if(fa||(fa=new ca(8192),ga=new DataView(fa.buffer,0,8192),ia=0),ha=fa.length-10,2048>ha-ia&&(fa=new ca(fa.length),ga=new DataView(fa.buffer,0,fa.length),ha=fa.length-10,ia=0),b=ia,f=i.structuredClone?new Map:null,c=i.structures,c){c.uninitialized&&(i.structures=c=i.getStructures());let a=c.length;if(a>j&&!k&&(a=j),!c.transitions){c.transitions=Object.create(null);for(let b,d=0;d<a;d++){if(b=c[d],!b)continue;let a,e=c.transitions;for(let c,d=0,f=b.length;d<f;d++)c=b[d],a=e[c],a||(a=e[c]=Object.create(null)),e=a;e[ja]=d+64}g=c.length}k||(c.nextId=a+64)}d&&(d=!1),e=c||[];try{// update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
if(p(a),i.offset=ia,f&&f.idsToInsert){ia+=6*f.idsToInsert.length,ia>ha&&r(ia),i.offset=ia;let a=t(fa.subarray(b,ia),f.idsToInsert);return f=null,a}return fa.subarray(b,ia);// position can change if we call pack again in saveStructures, so we get the buffer now
}finally{if(c){if(10>o&&o++,1e4<n)c.transitions=null,o=0,n=0,0<m.length&&(m=[]);else if(0<m.length&&!k){for(let a=0,b=m.length;a<b;a++)m[a][ja]=0;m=[]}if(d&&i.saveStructures){if(i.structures.length>j&&(i.structures=i.structures.slice(0,j)),!1===i.saveStructures(i.structures,g))return i.structures=i.getStructures()||[],i.pack(a);g=i.structures.length}}}};const p=a=>{ia>ha&&(fa=r(ia));var c,d=typeof a;if("string"==d){let b,d=a.length;b=32>d?1:256>d?2:65536>d?3:5;let e=3*d;if(ia+e>ha&&(fa=r(ia+e)),64>d||!h){let e,f,g,h=ia+b;for(e=0;e<d;e++)f=a.charCodeAt(e),128>f?fa[h++]=f:2048>f?(fa[h++]=192|f>>6,fa[h++]=128|63&f):55296==(64512&f)&&56320==(64512&(g=a.charCodeAt(e+1)))?(f=65536+((1023&f)<<10)+(1023&g),e++,fa[h++]=240|f>>18,fa[h++]=128|63&f>>12,fa[h++]=128|63&f>>6,fa[h++]=128|63&f):(fa[h++]=224|f>>12,fa[h++]=128|63&f>>6,fa[h++]=128|63&f);c=h-ia-b}else c=h(a,ia+b,e);32>c?fa[ia++]=160|c:256>c?(2>b&&fa.copyWithin(ia+2,ia+1,ia+1+c),fa[ia++]=217,fa[ia++]=c):65536>c?(3>b&&fa.copyWithin(ia+3,ia+2,ia+2+c),fa[ia++]=218,fa[ia++]=c>>8,fa[ia++]=255&c):(5>b&&fa.copyWithin(ia+5,ia+3,ia+3+c),fa[ia++]=219,ga.setUint32(ia,c),ia+=4),ia+=c}else if("number"===d){if(a>>>0===a)64>a?fa[ia++]=a:256>a?(fa[ia++]=204,fa[ia++]=a):65536>a?(fa[ia++]=205,fa[ia++]=a>>8,fa[ia++]=255&a):(fa[ia++]=206,ga.setUint32(ia,a),ia+=4);else if(a>>0===a)-32<=a?fa[ia++]=256+a:-128<=a?(fa[ia++]=208,fa[ia++]=a+256):-32768<=a?(fa[ia++]=209,ga.setInt16(ia,a),ia+=2):(fa[ia++]=210,ga.setInt32(ia,a),ia+=4);else{let b;if(0<(b=this.useFloat32)&&4294967296>a&&-2147483648<=a){fa[ia++]=202,ga.setFloat32(ia,a);let c;if(4>b||// this checks for  rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
(c=a*U[(127&fa[ia])<<1|fa[ia+1]>>7])>>0===c)return void(ia+=4);// move back into position for writing a double
ia--}fa[ia++]=203,ga.setFloat64(ia,a),ia+=8}}else if("object"===d){if(!a)fa[ia++]=192;else{if(f){let c=f.get(a);if(c){if(!c.id){let a=f.idsToInsert||(f.idsToInsert=[]);c.id=a.push(c)}return fa[ia++]=214,fa[ia++]=112,ga.setUint32(ia,c.id),void(ia+=4)}f.set(a,{offset:ia-b})}let d=a.constructor;if(d===Object)q(a,!0);else if(d===Array){c=a.length,16>c?fa[ia++]=144|c:65536>c?(fa[ia++]=220,fa[ia++]=c>>8,fa[ia++]=255&c):(fa[ia++]=221,ga.setUint32(ia,c),ia+=4);for(let b=0;b<c;b++)p(a[b])}else if(d===Map){c=a.size,16>c?fa[ia++]=128|c:65536>c?(fa[ia++]=222,fa[ia++]=c>>8,fa[ia++]=255&c):(fa[ia++]=223,ga.setUint32(ia,c),ia+=4);for(let[b,c]of a)p(b),p(c)}else{for(let b,c=0,d=_.length;c<d;c++)if(b=aa[c],a instanceof b){let b=_[c];if(b.write)return fa[ia++]=212,fa[ia++]=b.type,fa[ia++]=0,void p(b.write.call(this,a));let d=fa,e=ga,f=ia;fa=null;let g;try{g=b.pack.call(this,a,a=>(fa=d,d=null,ia+=a,ia>ha&&r(ia),{target:fa,targetView:ga,position:ia-a}),p)}finally{d&&(fa=d,ga=e,ia=f,ha=fa.length-10)}return void(g&&(g.length+ia>ha&&r(g.length+ia),ia=s(g,fa,ia,b.type)))}// no extension found, write as object
q(a,!a.hasOwnProperty)}}}else if("boolean"===d)fa[ia++]=a?195:194;else if("bigint"===d){if(a<BigInt(1)<<BigInt(63)&&a>=-(BigInt(1)<<BigInt(63)))fa[ia++]=211,ga.setBigInt64(ia,a);else if(a<BigInt(1)<<BigInt(64)&&0<a)fa[ia++]=207,ga.setBigUint64(ia,a);else// overflow
if(this.largeBigIntToFloat)fa[ia++]=203,ga.setFloat64(ia,+a);else throw new RangeError(a+" was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");ia+=8}else if("undefined"===d)this.encodeUndefinedAsNil?fa[ia++]=192:(fa[ia++]=212,fa[ia++]=0,fa[ia++]=0);else throw new Error("Unknown type "+d)},q=!1===this.useRecords?this.variableMapSize?a=>{// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
let b=Object.keys(a),c=b.length;16>c?fa[ia++]=128|c:65536>c?(fa[ia++]=222,fa[ia++]=c>>8,fa[ia++]=255&c):(fa[ia++]=223,ga.setUint32(ia,c),ia+=4);let d;for(let e=0;e<c;e++)p(d=b[e]),p(a[d])}:(a,c)=>{fa[ia++]=222;// always using map 16, so we can preallocate and set the length afterwards
let d=ia-b;ia+=2;let e=0;for(let b in a)(c||a.hasOwnProperty(b))&&(p(b),p(a[b]),e++);fa[d++ +b]=e>>8,fa[d+b]=255&e}:/*	sharedStructures ?  // For highly stable structures, using for-in can a little bit faster
			(object, safePrototype) => {
				let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))
				let objectOffset = position++ - start
				let wroteKeys
				for (let key in object) {
					if (safePrototype || object.hasOwnProperty(key)) {
						nextTransition = transition[key]
						if (!nextTransition) {
							nextTransition = transition[key] = Object.create(null)
							nextTransition.__keys__ = (transition.__keys__ || []).concat([key])
							/*let keys = Object.keys(object)
							if 
							let size = 0
							let startBranch = transition.__keys__ ? transition.__keys__.length : 0
							for (let i = 0, l = keys.length; i++) {
								let key = keys[i]
								size += key.length << 2
								if (i >= startBranch) {
									nextTransition = nextTransition[key] = Object.create(null)
									nextTransition.__keys__ = keys.slice(0, i + 1)
								}
							}
							makeRoom(position + size)
							nextTransition = transition[key]
							target.copy(target, )
							objectOffset
						}
						transition = nextTransition
						pack(object[key])
					}
				}
				let id = transition.id
				if (!id) {
					id = transition.id = structures.push(transition.__keys__) + 63
					if (sharedStructures.onUpdate)
						sharedStructures.onUpdate(id, transition.__keys__)
				}
				target[objectOffset + start] = id
			}*/a=>{let b,f=Object.keys(a),g=e.transitions||(e.transitions=Object.create(null)),h=0;for(let c,d=0,e=f.length;d<e;d++)c=f[d],b=g[c],b||(b=g[c]=Object.create(null),h++),g=b;let i=g[ja];i?fa[ia++]=i:(i=e.nextId++,!i&&(i=64,e.nextId=65),128<=i&&(e.nextId=(i=j+64)+1),g[ja]=i,e[63&i]=f,c&&c.length<=j?(fa[ia++]=i,d=!0):(fa[ia++]=212,fa[ia++]=114,fa[ia++]=i,h&&(n+=o*h),m.length>=64-j&&(m.shift()[ja]=0),m.push(g),p(f)));// now write the values
for(let b=0,c=f.length;b<c;b++)p(a[f[b]])},r=a=>{var c=Math.min,d=Math.round,e=Math.max;let f;if(16777216<a){// special handling for really large buffers
if(a-b>ea)throw new Error("Packed buffer would be larger than maximum buffer size");f=c(ea,4096*d(e((a-b)*(67108864<a?1.25:2),16777216)/4096))}else// faster handling for smaller buffers
f=(e(a-b<<2,fa.length-1)>>12)+1<<12;let g=new ca(f);return ga=new DataView(g.buffer,0,f),fa.copy?fa.copy(g,0,b,a):g.set(fa.slice(b,a)),ia-=b,b=0,ha=g.length-10,fa=g}}useBuffer(a){// this means we are finished using our own buffer and we can write over it safely
fa=a,ga=new DataView(fa.buffer,fa.byteOffset,fa.byteLength),ia=0}}aa=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor/*TypedArray*/,I],_=[{pack(a,c){let d=a.getTime()/1e3;if((this.useTimestamp32||0===a.getMilliseconds())&&0<=d&&4294967296>d){// Timestamp 32
let{target:a,targetView:b,position:e}=c(6);a[e++]=214,a[e++]=255,b.setUint32(e,d)}else if(0<d&&17179869184>d){// Timestamp 64
let{target:b,targetView:e,position:f}=c(10);b[f++]=215,b[f++]=255,e.setUint32(f,4e6*a.getMilliseconds()+(d/1e3/4294967296>>0)),e.setUint32(f+4,d)}else{// Timestamp 96
let{target:e,targetView:f,position:g}=c(15);e[g++]=199,e[g++]=12,e[g++]=255,f.setUint32(g,1e6*a.getMilliseconds()),f.setBigInt64(g+4,BigInt(b(d)))}}},{pack(a,b,c){let d=Array.from(a);if(this.structuredClone){let{target:a,position:c}=b(3);// 's' for Set
a[c++]=212,a[c++]=115,a[c++]=0}c(d)}},{pack(a,b,c){if(this.structuredClone){let{target:a,position:c}=b(3);// 'e' for error
a[c++]=212,a[c++]=101,a[c++]=0}c([a.name,a.message])}},{pack(a,b,c){if(this.structuredClone){let{target:a,position:c}=b(3);// 'x' for regeXp
a[c++]=212,a[c++]=120,a[c++]=0}c([a.source,a.flags])}},{pack(a,b){this.structuredClone?q(a,16,b):r(ba?Buffer.from(a):new Uint8Array(a),b)}},{pack(a,b){let c=a.constructor;c!==da&&this.structuredClone?q(a,T.indexOf(c.name),b):r(a,b)}},{pack(a,b){// specific 0xC1 object
let{target:c,position:d}=b(1);c[d]=193}}];let la=new ka({useRecords:!1});const ma=la.pack,na=la.pack,{NEVER:oa,ALWAYS:pa,DECIMAL_ROUND:qa,DECIMAL_FIT:ra}=Z;a.ALWAYS=pa,a.C1=J,a.DECIMAL_FIT=ra,a.DECIMAL_ROUND=qa,a.Decoder=i,a.Encoder=ka,a.FLOAT32_OPTIONS=Z,a.NEVER=oa,a.Packr=ka,a.Unpackr=i,a.addExtension=u,a.clearSource=o,a.decode=Y,a.encode=na,a.mapsAsObjects=!0,a.pack=ma,a.unpack=W,a.unpackMultiple=X,a.useRecords=!1,Object.defineProperty(a,"__esModule",{value:!0})});
